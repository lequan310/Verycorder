import { BrowserView, BrowserWindow, ipcMain, webContents } from "electron";
import { handleUrl } from "./utilities";
import { TestCase } from "../Types/testCase";
import { ChangeUrlResult } from "../Types/urlResult";
import { BLANK_PAGE, Channel } from "./listenerConst";


// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const BROWSER_VIEW_PRELOAD_WEBPACK_ENTRY: string;

let recording = false;
let replaying = false;
let testCase: TestCase;
let abortController: AbortController;

let win: BrowserWindow;
let view: BrowserView;


// Getter for win
export function getWin(): BrowserWindow {
  return win;
}

// Getter for view
export function getView(): BrowserView {
  return view;
}


// Function to create the web view to load webs
export function createBrowserView() {
  view = new BrowserView({
    webPreferences: {
      preload: BROWSER_VIEW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  view.webContents.loadURL(BLANK_PAGE); // Load blank page on start

  view.webContents.on("did-navigate", async (event, url) => {
    if (url === BLANK_PAGE) return;
    win.webContents.send(Channel.UPDATE_URL, url); // Update URL in search bar
  });

  view.webContents.on("did-navigate-in-page", async (event, url) => {
    win.webContents.send(Channel.UPDATE_URL, url); // Update URL in search bar
  });
}

export const createWindow = (): void => {
  // Create the browser window.
  win = new BrowserWindow({
    width: 1280,
    height: 720,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  createBrowserView();
  win.setBrowserView(view);

  // Clear cache
  view.webContents.session.clearCache();
  // Maximize app on launch
  win.maximize();
  // Update view bounds for the app
  updateViewBounds(win);
  // Disable menu bar
  win.setMenu(null);
  // and load the index.html of the app.
  win.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  //win.webContents.openDevTools({ mode: "detach" });

  // Handle resize app
  win.on("resize", () => updateViewBounds(win));
  // Handle window close
  win.on("closed", () => { win = null; });
};


function getCurrentMode() {
  return recording ? "record" : replaying ? "replay" : "normal";
}

export function toggleRecord(win: BrowserWindow) {
  if (replaying) return;
  const view = win.getBrowserView();
  if (view.webContents.getURL() === "" || view.webContents.getURL() === BLANK_PAGE) return;

  recording = !recording;

  if (recording) {
    const { x, y, width, height } = view.getBounds();
    testCase = {
      url: view.webContents.getURL(),
      events: [],
      size: { width, height },
    };
  }

  view.webContents.send(Channel.TOGGLE_RECORD, recording); // Send message to attach event listeners
  win.webContents.send(Channel.TOGGLE_RECORD, recording); // Send message to change UI (disable search bar)
  console.log(`Recording: ${recording}`);
}

export function toggleReplay(win: BrowserWindow) {
  if (recording) return;
  const view = win.getBrowserView();
  if (view.webContents.getURL() === "" || view.webContents.getURL() === BLANK_PAGE) return;

  replaying = !replaying;

  
  if (testCase && testCase.events && testCase.events.length > 0) {


    view.webContents.send(Channel.SEND_EVENT, testCase); // Send test case to process for replay.
    
    //view.webContents.loadURL(testCase.url); // Load the URL to replay 
    
    view.webContents.send(Channel.TOGGLE_REPLAY, replaying); // Send message to toggle playback
    
    console.log('replaying : ', replaying);


  }
  else {
    //view.webContents.send(Channel.TOGGLE_REPLAY, replaying); // Send message to toggle playback
    console.log('There are no test cases.')
  }
}

// Handle URL change via search bar with abort controller
function changeUrlWithAbort(url: string, view: BrowserView, signal: AbortSignal): Promise<ChangeUrlResult> {
  if (!url) {
    // If the URL is invalid
    view.webContents.loadURL(BLANK_PAGE);
    return Promise.resolve({ success: false, message: "Invalid URL" });
  }

  if (!view) {
    // If there is no browser view available
    view.webContents.loadURL(BLANK_PAGE);
    return Promise.resolve({ success: false, message: "Browser view error" });
  }

  return new Promise<ChangeUrlResult>((resolve, reject) => {
    if (signal.aborted) {
      reject(new Error('Aborted'));
      return;
    }

    const handleAbort = () => {
      reject(new Error('Aborted'));
    };

    signal.addEventListener('abort', handleAbort);

    view.webContents.loadURL(url)
      .then(() => {
        signal.removeEventListener('abort', handleAbort);
        resolve({ success: true, message: "Success" });
      })
      .catch((error) => {
        signal.removeEventListener('abort', handleAbort);
        resolve({ success: false, message: "Cannot connect to URL" });
      });
  });
}

// Update size and location of browser view
export function updateViewBounds(win: BrowserWindow) {
  if (win) {
    const bounds = win.getContentBounds();
    const view = win.getBrowserView();
    if (view) {
      const { x, y, width, height } = bounds;
      view.setBounds({
        x: Math.floor(width / 2),
        y: 70,
        width: Math.floor(width / 2 - 12),
        height: Math.floor(height - 70 - 12),
      });
    }
  }
}

// Handle UI events from React to Electron
export function handleUIEvents(win: BrowserWindow) {
  const view = win.getBrowserView();

  // Handle URL change in React
  ipcMain.handle(Channel.URL_CHANGE, async (event, url) => {
    // Abort controller stuff
    if (abortController) abortController.abort();
    abortController = new AbortController();
    const signal = abortController.signal;

    url = handleUrl(url); // Assume this function properly formats the URL
    const response = await changeUrlWithAbort(url, view, signal).catch((error) => console.log("Aborted"));
    return response;
  });

  ipcMain.on(Channel.UPDATE_TEST_CASE, (event, updatedEventList) => {
    testCase.events = updatedEventList;
    console.log(testCase);
  });

  ipcMain.on(Channel.CLICK_RECORD, (event) => {
    toggleRecord(win);
  });
}

// Function to register events (click, input, etc.) into left panel
export function handleRecordEvents(win: BrowserWindow, eventNames: string[]) {
  for (const eventName of eventNames) {
    ipcMain.on(eventName, (event, data) => {
      //testCase.events.push(data);
      win.webContents.send(Channel.ADD_EVENT, data);
      //console.log(data);
    });
  }
}

export function handleViewEvents() {
  ipcMain.handle(Channel.GET_MODE, async (event) => {
    return getCurrentMode();
  });
}

export function testLogEvents() {
  ipcMain.on(Channel.TEST_LOG, (event, data) => {
    console.log(data);
  });
}


export function gotourl(win: BrowserWindow){
  if (getCurrentMode() === "normal" && testCase && testCase.events && testCase.events.length > 0) {
    const view = win.getBrowserView(); 
    console.log('Load URL: ' + testCase.url); 
    view.webContents.loadURL(testCase.url);
  }
  else {
    console.log('Cant load because current mode is ', getCurrentMode());
  }
}


export function inputer() {
  ipcMain.on(Channel.REPLAY_INPUT, async (event, data) => {
    console.log('Inputer function called');
    console.log(data);
    console.log(data.x, data.y);
    console.log(data.value);
    // Simulate key press for each character in data.value
    for (const char of data.value) {
      view.webContents.sendInputEvent({ type: 'char', keyCode: char });
    }
    console.log('Inputed' + data.value +  ' at ', data.x, data.y);
    //replayView.webContents.sendInputEvent({ type: 'keyDown', keyCode: char });
    //replayView.webContents.sendInputEvent({ type: 'keyUp', keyCode: char });
    
    //const focusedWebContents = webContents.getFocusedWebContents(); // Get the currently focused webContents
    // if (focusedWebContents) {
    //   for (const char of data.value) {
    //     // Simulate key press for each character in data.value
    //     focusedWebContents.sendInputEvent({ type: 'keyDown', keyCode: char });
    //     focusedWebContents.sendInputEvent({ type: 'keyUp', keyCode: char });
    //   }
    // }
  });

}

export function hoverer() {
  ipcMain.on(Channel.REPLAY_HOVER, async (event, data) => {
    console.log('Hoverer function called');
    console.log(data);
    console.log(data.x, data.y);
    hoverEvent(data.x, data.y);
  });

}

// Function used to simulate hover event
function hoverEvent(x: number, y: number) {
  view.webContents.sendInputEvent({
    type: 'mouseMove',
    x: x,
    y: y,
    movementX: 250,
    movementY: 250,
  });

  // replayView.webContents.sendInputEvent({
  //   type: 'mouseEnter',
  //   x: x,
  //   y: y,
  // });
}

// Function used to simulate click event
export function clicker() {
  ipcMain.on(Channel.REPLAY_CLICK, async (event, data) => {
    console.log('Clicker function called');
    console.log(data);
    console.log(data.x, data.y);
    
    //Hover over the element first
    hoverEvent(data.x, data.y);
    
    // Click the element
    view.webContents.sendInputEvent({
      type: 'mouseDown',
      x: data.x,
      y: data.y,
      button: 'left',
      clickCount: 1
    });
    view.webContents.sendInputEvent({
      type: 'mouseUp',
      x: data.x,
      y: data.y,
      button: 'left',
      clickCount: 1
    });
    console.log('Clicked at ', data.x, data.y);
    
  });
}


// Replay feature functions
export function scroller() {
  
  ipcMain.on(Channel.REPLAY_SCROLL, async (event, data) => {
    console.log('Scroller function called');


    // Send the mouseWheel event with the calculated deltaY to scroll
    if (data.type === 'vertical') {
    view.webContents.sendInputEvent({
      type: 'mouseWheel',
      x: 0,
      y: 0,
      deltaX: 0,
      deltaY: data.deltaY*-1, 
      canScroll: true
    });
    } else if (data.type === 'horizontal') {
      view.webContents.sendInputEvent({
        type: 'mouseWheel',
        x: 0,
        y: 0,
        deltaX: data.deltaX*-1,
        deltaY: 0, 
        canScroll: true
      });  
    }
    console.log('Scrolled to ', data);
  });
}

